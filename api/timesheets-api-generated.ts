/* tslint:disable */
/* eslint-disable */
/*
Expense Reports

API Documentation

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { TimesheetsClockIn401Response } from '../models';
// @ts-ignore
import { TimesheetsClockIn403Response } from '../models';
// @ts-ignore
import { TimesheetsClockIn409Response } from '../models';
// @ts-ignore
import { TimesheetsClockInResponse } from '../models';
// @ts-ignore
import { TimesheetsClockOut401Response } from '../models';
// @ts-ignore
import { TimesheetsClockOut409Response } from '../models';
// @ts-ignore
import { TimesheetsClockOutResponse } from '../models';
// @ts-ignore
import { TimesheetsCreateOrUpdateTimesheet401Response } from '../models';
// @ts-ignore
import { TimesheetsCreateOrUpdateTimesheet403Response } from '../models';
// @ts-ignore
import { TimesheetsCreateOrUpdateTimesheet409Response } from '../models';
// @ts-ignore
import { TimesheetsCreateOrUpdateTimesheetResponse } from '../models';
// @ts-ignore
import { TimesheetsDeleteByTimesheetId401Response } from '../models';
// @ts-ignore
import { TimesheetsDeleteByTimesheetId409Response } from '../models';
// @ts-ignore
import { TimesheetsDeleteByTimesheetIdResponse } from '../models';
// @ts-ignore
import { TimesheetsGetActiveAllocations401Response } from '../models';
// @ts-ignore
import { TimesheetsGetActiveAllocations409Response } from '../models';
// @ts-ignore
import { TimesheetsGetActiveAllocationsResponse } from '../models';
// @ts-ignore
import { TimesheetsGetApprovalList401Response } from '../models';
// @ts-ignore
import { TimesheetsGetApprovalList409Response } from '../models';
// @ts-ignore
import { TimesheetsGetApprovalListResponse } from '../models';
// @ts-ignore
import { TimesheetsGetByTimesheetId401Response } from '../models';
// @ts-ignore
import { TimesheetsGetByTimesheetId409Response } from '../models';
// @ts-ignore
import { TimesheetsGetByUserId401Response } from '../models';
// @ts-ignore
import { TimesheetsGetByUserId409Response } from '../models';
// @ts-ignore
import { TimesheetsGetDetailsByTimesheetId401Response } from '../models';
// @ts-ignore
import { TimesheetsGetDetailsByTimesheetId403Response } from '../models';
// @ts-ignore
import { TimesheetsGetDetailsByTimesheetId404Response } from '../models';
// @ts-ignore
import { TimesheetsGetDetailsByTimesheetId409Response } from '../models';
// @ts-ignore
import { TimesheetsGetPreferencesByCid401Response } from '../models';
// @ts-ignore
import { TimesheetsGetPreferencesByCid409Response } from '../models';
// @ts-ignore
import { TimesheetsGetPreferencesByCidResponse } from '../models';
// @ts-ignore
import { TimesheetsGetTimecardsByTimesheetId401Response } from '../models';
// @ts-ignore
import { TimesheetsGetTimecardsByTimesheetId409Response } from '../models';
// @ts-ignore
import { TimesheetsListActivityTypesByCid401Response } from '../models';
// @ts-ignore
import { TimesheetsListActivityTypesByCid409Response } from '../models';
// @ts-ignore
import { TimesheetsListActivityTypesByCidResponse } from '../models';
// @ts-ignore
import { TimesheetsUpdateStatusByTimesheetId401Response } from '../models';
// @ts-ignore
import { TimesheetsUpdateStatusByTimesheetId409Response } from '../models';
// @ts-ignore
import { TimesheetsUpdateStatusByTimesheetIdResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TimesheetsApi - axios parameter creator
 * @export
 */
export const TimesheetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows to clock in.
         * @summary Clock in.
         * @param {number} [proceedOutsideGeoFence] To clockin outside geofence
         * @param {string} [description] Description of timecard.
         * @param {number} [projectId] Project ID of project.
         * @param {string} [projectManager] Project Manager corresponding user.
         * @param {'RG' | 'OT'} [categoryCode] Category of timecard. Choose between [\&quot;Regular\&quot;, \&quot;Overtime\&quot;].
         * @param {string} [notes] Notes.
         * @param {'Y' | 'N'} [billable] Billable or non- billable timecard. Select \&#39;Y\&#39; for billable and \&#39;N\&#39; for non-billable
         * @param {string} [activity] Activity type of timecard.
         * @param {string} [approvalRejectionReason] Reason for approval rejection.
         * @param {number} [clockInLongitude] Longitude value while clocking in.
         * @param {number} [clockInLatitude] Latitude value while clocking in.
         * @param {number} [clockOutLongitude] Longitude value while clocking out.
         * @param {number} [clockOutLatitude] Latitude value while clocking out.
         * @param {number} [projectAreaId] Project area ID of project area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn: async (proceedOutsideGeoFence?: number, description?: string, projectId?: number, projectManager?: string, categoryCode?: 'RG' | 'OT', notes?: string, billable?: 'Y' | 'N', activity?: string, approvalRejectionReason?: string, clockInLongitude?: number, clockInLatitude?: number, clockOutLongitude?: number, clockOutLatitude?: number, projectAreaId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheet/clockin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (proceedOutsideGeoFence !== undefined) {
                localVarQueryParameter['proceedOutsideGeoFence'] = proceedOutsideGeoFence;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectManager !== undefined) {
                localVarQueryParameter['projectManager'] = projectManager;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (billable !== undefined) {
                localVarQueryParameter['billable'] = billable;
            }

            if (activity !== undefined) {
                localVarQueryParameter['activity'] = activity;
            }

            if (approvalRejectionReason !== undefined) {
                localVarQueryParameter['approvalRejectionReason'] = approvalRejectionReason;
            }

            if (clockInLongitude !== undefined) {
                localVarQueryParameter['clockInLongitude'] = clockInLongitude;
            }

            if (clockInLatitude !== undefined) {
                localVarQueryParameter['clockInLatitude'] = clockInLatitude;
            }

            if (clockOutLongitude !== undefined) {
                localVarQueryParameter['clockOutLongitude'] = clockOutLongitude;
            }

            if (clockOutLatitude !== undefined) {
                localVarQueryParameter['clockOutLatitude'] = clockOutLatitude;
            }

            if (projectAreaId !== undefined) {
                localVarQueryParameter['projectAreaId'] = projectAreaId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/clockin',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows user to clock out.
         * @summary Clock out.
         * @param {number} [proceedOutsideGeoFence] clock out outside geofence
         * @param {string} [description] Description of timecard.
         * @param {number} [projectId] Project ID of project.
         * @param {string} [projectManager] Project Manager corresponding user.
         * @param {'RG' | 'OT'} [categoryCode] Category of timecard. Choose between [\&quot;Regular\&quot;, \&quot;Overtime\&quot;].
         * @param {string} [notes] Notes.
         * @param {'Y' | 'N'} [billable] Billable or non- billable timecard. Select \&#39;Y\&#39; for billable and \&#39;N\&#39; for non-billable
         * @param {string} [activity] Activity type of timecard.
         * @param {string} [approvalRejectionReason] Reason for approval rejection.
         * @param {number} [clockInLongitude] Longitude value while clocking in.
         * @param {number} [clockInLatitude] Latitude value while clocking in.
         * @param {number} [clockOutLongitude] Longitude value while clocking out.
         * @param {number} [clockOutLatitude] Latitude value while clocking out.
         * @param {number} [projectAreaId] Project area ID of project area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut: async (proceedOutsideGeoFence?: number, description?: string, projectId?: number, projectManager?: string, categoryCode?: 'RG' | 'OT', notes?: string, billable?: 'Y' | 'N', activity?: string, approvalRejectionReason?: string, clockInLongitude?: number, clockInLatitude?: number, clockOutLongitude?: number, clockOutLatitude?: number, projectAreaId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheet/clockout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (proceedOutsideGeoFence !== undefined) {
                localVarQueryParameter['proceedOutsideGeoFence'] = proceedOutsideGeoFence;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectManager !== undefined) {
                localVarQueryParameter['projectManager'] = projectManager;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (billable !== undefined) {
                localVarQueryParameter['billable'] = billable;
            }

            if (activity !== undefined) {
                localVarQueryParameter['activity'] = activity;
            }

            if (approvalRejectionReason !== undefined) {
                localVarQueryParameter['approvalRejectionReason'] = approvalRejectionReason;
            }

            if (clockInLongitude !== undefined) {
                localVarQueryParameter['clockInLongitude'] = clockInLongitude;
            }

            if (clockInLatitude !== undefined) {
                localVarQueryParameter['clockInLatitude'] = clockInLatitude;
            }

            if (clockOutLongitude !== undefined) {
                localVarQueryParameter['clockOutLongitude'] = clockOutLongitude;
            }

            if (clockOutLatitude !== undefined) {
                localVarQueryParameter['clockOutLatitude'] = clockOutLatitude;
            }

            if (projectAreaId !== undefined) {
                localVarQueryParameter['projectAreaId'] = projectAreaId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/clockout',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new timesheet and update existing timesheet.
         * @summary Create/Update a timesheet.
         * @param {string | Date} date Timesheet date.
         * @param {number} projectId Project ID of project.
         * @param {string} elapsedTime Elapsed Time of timecard.
         * @param {number} [cardId] Timecard Id of timecard.
         * @param {string} [description] Description of timecard.
         * @param {number} [clockedOutsideGeofence] Clocked in or clocked out outside geofence.
         * @param {string} [projectManager] Project Manager corresponding user.
         * @param {'RG' | 'OT'} [categoryCode] Category of timecard. Choose between [\&quot;Regular\&quot;, \&quot;Overtime\&quot;].
         * @param {string} [notes] Notes.
         * @param {'Y' | 'N'} [billable] Billable or non- billable timecard. Select \&#39;Y\&#39; for billable and \&#39;N\&#39; for non-billable
         * @param {string} [activity] Activity type of timecard.
         * @param {string} [approvalRejectionReason] Reason for approval rejection.
         * @param {number} [clockInLongitude] Longitude value while clocking in.
         * @param {number} [clockInLatitude] Latitude value while clocking in.
         * @param {number} [clockOutLongitude] Longitude value while clocking out.
         * @param {number} [clockOutLatitude] Latitude value while clocking out.
         * @param {number} [projectAreaId] Project area ID of project area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTimesheet: async (date: string | Date, projectId: number, elapsedTime: string, cardId?: number, description?: string, clockedOutsideGeofence?: number, projectManager?: string, categoryCode?: 'RG' | 'OT', notes?: string, billable?: 'Y' | 'N', activity?: string, approvalRejectionReason?: string, clockInLongitude?: number, clockInLatitude?: number, clockOutLongitude?: number, clockOutLatitude?: number, projectAreaId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('createOrUpdateTimesheet', 'date', date)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createOrUpdateTimesheet', 'projectId', projectId)
            // verify required parameter 'elapsedTime' is not null or undefined
            assertParamExists('createOrUpdateTimesheet', 'elapsedTime', elapsedTime)
            const localVarPath = `/api/timesheet/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (elapsedTime !== undefined) {
                localVarQueryParameter['elapsedTime'] = (elapsedTime as any instanceof Date) ?
                    (elapsedTime as any).toISOString() :
                    elapsedTime;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (clockedOutsideGeofence !== undefined) {
                localVarQueryParameter['clockedOutsideGeofence'] = clockedOutsideGeofence;
            }

            if (projectManager !== undefined) {
                localVarQueryParameter['projectManager'] = projectManager;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (billable !== undefined) {
                localVarQueryParameter['billable'] = billable;
            }

            if (activity !== undefined) {
                localVarQueryParameter['activity'] = activity;
            }

            if (approvalRejectionReason !== undefined) {
                localVarQueryParameter['approvalRejectionReason'] = approvalRejectionReason;
            }

            if (clockInLongitude !== undefined) {
                localVarQueryParameter['clockInLongitude'] = clockInLongitude;
            }

            if (clockInLatitude !== undefined) {
                localVarQueryParameter['clockInLatitude'] = clockInLatitude;
            }

            if (clockOutLongitude !== undefined) {
                localVarQueryParameter['clockOutLongitude'] = clockOutLongitude;
            }

            if (clockOutLatitude !== undefined) {
                localVarQueryParameter['clockOutLatitude'] = clockOutLatitude;
            }

            if (projectAreaId !== undefined) {
                localVarQueryParameter['projectAreaId'] = projectAreaId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/save',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a timesheet by Timesheet ID.
         * @summary Delete a timesheet.
         * @param {number} timesheetId Timesheet ID of timesheet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByTimesheetId: async (timesheetId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timesheetId' is not null or undefined
            assertParamExists('deleteByTimesheetId', 'timesheetId', timesheetId)
            const localVarPath = `/api/timesheet/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/delete',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of active allocations of user.
         * @summary Retrieve my active allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAllocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheet/allocations/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/allocations/list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of timesheet approvals on the basis of permission.
         * @summary Retrieve timesheet approvals.
         * @param {string} startDate Start date of the timesheet.
         * @param {string} endDate End date of the timesheet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalList: async (startDate: string, endDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getApprovalList', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getApprovalList', 'endDate', endDate)
            const localVarPath = `/api/timesheet/approvals/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/approvals/list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a timesheet by timesheet ID.
         * @summary Retrieve a timesheet by timesheet ID.
         * @param {number} timesheetId Tmesheet ID of timesheet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByTimesheetId: async (timesheetId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timesheetId' is not null or undefined
            assertParamExists('getByTimesheetId', 'timesheetId', timesheetId)
            const localVarPath = `/api/timesheet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of timesheets.
         * @summary Retrieve timesheets by User ID.
         * @param {string} [startDate] Start date of the timesheet.
         * @param {string} [endDate] End date of the timesheet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId: async (startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheets',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve timesheet details by Timesheet ID.
         * @summary Retrieve timesheet details by Timesheet ID.
         * @param {number} timeSheetId Timesheet ID of timesheet.
         * @param {boolean} [flatcustomfields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsByTimesheetId: async (timeSheetId: number, flatcustomfields?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeSheetId' is not null or undefined
            assertParamExists('getDetailsByTimesheetId', 'timeSheetId', timeSheetId)
            const localVarPath = `/api/timesheets/details/{timeSheetId}`
                .replace(`{${"timeSheetId"}}`, encodeURIComponent(String(timeSheetId !== undefined ? timeSheetId : `-timeSheetId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (flatcustomfields !== undefined) {
                localVarQueryParameter['flatcustomfields'] = flatcustomfields;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheets/details/{timeSheetId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of timesheet preferences based in cid.
         * @summary Retrieve my timesheet preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreferencesByCid: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheet/preferences/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/preferences/list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of timecards.
         * @summary Retrieve timecards by Timesheet ID.
         * @param {string | Date} startDate Start date of the timesheet.
         * @param {string | Date} endDate End date of the timesheet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimecardsByTimesheetId: async (startDate: string | Date, endDate: string | Date, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getTimecardsByTimesheetId', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getTimecardsByTimesheetId', 'endDate', endDate)
            const localVarPath = `/api/timecards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timecards',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of activity types based on cid.
         * @summary Retrieve list of activity types based on cid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityTypesByCid: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/timesheet/activitytype/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/activitytype/list',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the timesheet status (submit, approve, reject) corresponding to supplied Timesheet ID.
         * @summary Update timesheet status by Timesheet ID.
         * @param {number} timesheetId Timesheet ID of the timesheet.
         * @param {'PD' | 'PAP' | 'AP' | 'NEW' | 'RJ'} status Status of timecard. Choose between [\&quot;PD-Pending for Approval\&quot;, \&quot;PAP-Partially Approved\&quot;, \&quot;AP-Fully Approved\&quot;,\&quot;NEW-New Timesheet\&quot;,\&quot;RJ-Rejected\&quot;].
         * @param {string} [comments] Comments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusByTimesheetId: async (timesheetId: number, status: 'PD' | 'PAP' | 'AP' | 'NEW' | 'RJ', comments?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timesheetId' is not null or undefined
            assertParamExists('updateStatusByTimesheetId', 'timesheetId', timesheetId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateStatusByTimesheetId', 'status', status)
            const localVarPath = `/api/timesheet/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (comments !== undefined) {
                localVarQueryParameter['comments'] = comments;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timesheet/update',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimesheetsApi - functional programming interface
 * @export
 */
export const TimesheetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimesheetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows to clock in.
         * @summary Clock in.
         * @param {TimesheetsApiClockInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockIn(requestParameters: TimesheetsApiClockInRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsClockInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockIn(requestParameters.proceedOutsideGeoFence, requestParameters.description, requestParameters.projectId, requestParameters.projectManager, requestParameters.categoryCode, requestParameters.notes, requestParameters.billable, requestParameters.activity, requestParameters.approvalRejectionReason, requestParameters.clockInLongitude, requestParameters.clockInLatitude, requestParameters.clockOutLongitude, requestParameters.clockOutLatitude, requestParameters.projectAreaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows user to clock out.
         * @summary Clock out.
         * @param {TimesheetsApiClockOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockOut(requestParameters: TimesheetsApiClockOutRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsClockOutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockOut(requestParameters.proceedOutsideGeoFence, requestParameters.description, requestParameters.projectId, requestParameters.projectManager, requestParameters.categoryCode, requestParameters.notes, requestParameters.billable, requestParameters.activity, requestParameters.approvalRejectionReason, requestParameters.clockInLongitude, requestParameters.clockInLatitude, requestParameters.clockOutLongitude, requestParameters.clockOutLatitude, requestParameters.projectAreaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new timesheet and update existing timesheet.
         * @summary Create/Update a timesheet.
         * @param {TimesheetsApiCreateOrUpdateTimesheetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateTimesheet(requestParameters: TimesheetsApiCreateOrUpdateTimesheetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsCreateOrUpdateTimesheetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateTimesheet(requestParameters.date, requestParameters.projectId, requestParameters.elapsedTime, requestParameters.cardId, requestParameters.description, requestParameters.clockedOutsideGeofence, requestParameters.projectManager, requestParameters.categoryCode, requestParameters.notes, requestParameters.billable, requestParameters.activity, requestParameters.approvalRejectionReason, requestParameters.clockInLongitude, requestParameters.clockInLatitude, requestParameters.clockOutLongitude, requestParameters.clockOutLatitude, requestParameters.projectAreaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a timesheet by Timesheet ID.
         * @summary Delete a timesheet.
         * @param {TimesheetsApiDeleteByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteByTimesheetId(requestParameters: TimesheetsApiDeleteByTimesheetIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsDeleteByTimesheetIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteByTimesheetId(requestParameters.timesheetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of active allocations of user.
         * @summary Retrieve my active allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveAllocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsGetActiveAllocationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveAllocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of timesheet approvals on the basis of permission.
         * @summary Retrieve timesheet approvals.
         * @param {TimesheetsApiGetApprovalListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovalList(requestParameters: TimesheetsApiGetApprovalListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsGetApprovalListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalList(requestParameters.startDate, requestParameters.endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a timesheet by timesheet ID.
         * @summary Retrieve a timesheet by timesheet ID.
         * @param {TimesheetsApiGetByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByTimesheetId(requestParameters: TimesheetsApiGetByTimesheetIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByTimesheetId(requestParameters.timesheetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of timesheets.
         * @summary Retrieve timesheets by User ID.
         * @param {TimesheetsApiGetByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserId(requestParameters: TimesheetsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserId(requestParameters.startDate, requestParameters.endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve timesheet details by Timesheet ID.
         * @summary Retrieve timesheet details by Timesheet ID.
         * @param {TimesheetsApiGetDetailsByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailsByTimesheetId(requestParameters: TimesheetsApiGetDetailsByTimesheetIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailsByTimesheetId(requestParameters.timeSheetId, requestParameters.flatcustomfields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of timesheet preferences based in cid.
         * @summary Retrieve my timesheet preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPreferencesByCid(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsGetPreferencesByCidResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPreferencesByCid(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of timecards.
         * @summary Retrieve timecards by Timesheet ID.
         * @param {TimesheetsApiGetTimecardsByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimecardsByTimesheetId(requestParameters: TimesheetsApiGetTimecardsByTimesheetIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimecardsByTimesheetId(requestParameters.startDate, requestParameters.endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve list of activity types based on cid.
         * @summary Retrieve list of activity types based on cid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActivityTypesByCid(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsListActivityTypesByCidResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActivityTypesByCid(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the timesheet status (submit, approve, reject) corresponding to supplied Timesheet ID.
         * @summary Update timesheet status by Timesheet ID.
         * @param {TimesheetsApiUpdateStatusByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusByTimesheetId(requestParameters: TimesheetsApiUpdateStatusByTimesheetIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimesheetsUpdateStatusByTimesheetIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusByTimesheetId(requestParameters.timesheetId, requestParameters.status, requestParameters.comments, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimesheetsApi - factory interface
 * @export
 */
export const TimesheetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimesheetsApiFp(configuration)
    return {
        /**
         * Allows to clock in.
         * @summary Clock in.
         * @param {TimesheetsApiClockInRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockIn(requestParameters: TimesheetsApiClockInRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TimesheetsClockInResponse> {
            return localVarFp.clockIn(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows user to clock out.
         * @summary Clock out.
         * @param {TimesheetsApiClockOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut(requestParameters: TimesheetsApiClockOutRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TimesheetsClockOutResponse> {
            return localVarFp.clockOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new timesheet and update existing timesheet.
         * @summary Create/Update a timesheet.
         * @param {TimesheetsApiCreateOrUpdateTimesheetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateTimesheet(requestParameters: TimesheetsApiCreateOrUpdateTimesheetRequest, options?: AxiosRequestConfig): AxiosPromise<TimesheetsCreateOrUpdateTimesheetResponse> {
            return localVarFp.createOrUpdateTimesheet(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a timesheet by Timesheet ID.
         * @summary Delete a timesheet.
         * @param {TimesheetsApiDeleteByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteByTimesheetId(requestParameters: TimesheetsApiDeleteByTimesheetIdRequest, options?: AxiosRequestConfig): AxiosPromise<TimesheetsDeleteByTimesheetIdResponse> {
            return localVarFp.deleteByTimesheetId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of active allocations of user.
         * @summary Retrieve my active allocations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveAllocations(options?: AxiosRequestConfig): AxiosPromise<TimesheetsGetActiveAllocationsResponse> {
            return localVarFp.getActiveAllocations(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of timesheet approvals on the basis of permission.
         * @summary Retrieve timesheet approvals.
         * @param {TimesheetsApiGetApprovalListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovalList(requestParameters: TimesheetsApiGetApprovalListRequest, options?: AxiosRequestConfig): AxiosPromise<TimesheetsGetApprovalListResponse> {
            return localVarFp.getApprovalList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a timesheet by timesheet ID.
         * @summary Retrieve a timesheet by timesheet ID.
         * @param {TimesheetsApiGetByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByTimesheetId(requestParameters: TimesheetsApiGetByTimesheetIdRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getByTimesheetId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of timesheets.
         * @summary Retrieve timesheets by User ID.
         * @param {TimesheetsApiGetByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId(requestParameters: TimesheetsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve timesheet details by Timesheet ID.
         * @summary Retrieve timesheet details by Timesheet ID.
         * @param {TimesheetsApiGetDetailsByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsByTimesheetId(requestParameters: TimesheetsApiGetDetailsByTimesheetIdRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDetailsByTimesheetId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of timesheet preferences based in cid.
         * @summary Retrieve my timesheet preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPreferencesByCid(options?: AxiosRequestConfig): AxiosPromise<TimesheetsGetPreferencesByCidResponse> {
            return localVarFp.getPreferencesByCid(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of timecards.
         * @summary Retrieve timecards by Timesheet ID.
         * @param {TimesheetsApiGetTimecardsByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimecardsByTimesheetId(requestParameters: TimesheetsApiGetTimecardsByTimesheetIdRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getTimecardsByTimesheetId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of activity types based on cid.
         * @summary Retrieve list of activity types based on cid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActivityTypesByCid(options?: AxiosRequestConfig): AxiosPromise<TimesheetsListActivityTypesByCidResponse> {
            return localVarFp.listActivityTypesByCid(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the timesheet status (submit, approve, reject) corresponding to supplied Timesheet ID.
         * @summary Update timesheet status by Timesheet ID.
         * @param {TimesheetsApiUpdateStatusByTimesheetIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusByTimesheetId(requestParameters: TimesheetsApiUpdateStatusByTimesheetIdRequest, options?: AxiosRequestConfig): AxiosPromise<TimesheetsUpdateStatusByTimesheetIdResponse> {
            return localVarFp.updateStatusByTimesheetId(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clockIn operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiClockInRequest
 */
export type TimesheetsApiClockInRequest = {
    
    /**
    * To clockin outside geofence
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly proceedOutsideGeoFence?: number
    
    /**
    * Description of timecard.
    * @type {string}
    * @memberof TimesheetsApiClockIn
    */
    readonly description?: string
    
    /**
    * Project ID of project.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly projectId?: number
    
    /**
    * Project Manager corresponding user.
    * @type {string}
    * @memberof TimesheetsApiClockIn
    */
    readonly projectManager?: string
    
    /**
    * Category of timecard. Choose between [\"Regular\", \"Overtime\"].
    * @type {'RG' | 'OT'}
    * @memberof TimesheetsApiClockIn
    */
    readonly categoryCode?: 'RG' | 'OT'
    
    /**
    * Notes.
    * @type {string}
    * @memberof TimesheetsApiClockIn
    */
    readonly notes?: string
    
    /**
    * Billable or non- billable timecard. Select \'Y\' for billable and \'N\' for non-billable
    * @type {'Y' | 'N'}
    * @memberof TimesheetsApiClockIn
    */
    readonly billable?: 'Y' | 'N'
    
    /**
    * Activity type of timecard.
    * @type {string}
    * @memberof TimesheetsApiClockIn
    */
    readonly activity?: string
    
    /**
    * Reason for approval rejection.
    * @type {string}
    * @memberof TimesheetsApiClockIn
    */
    readonly approvalRejectionReason?: string
    
    /**
    * Longitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly clockInLongitude?: number
    
    /**
    * Latitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly clockInLatitude?: number
    
    /**
    * Longitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly clockOutLongitude?: number
    
    /**
    * Latitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly clockOutLatitude?: number
    
    /**
    * Project area ID of project area.
    * @type {number}
    * @memberof TimesheetsApiClockIn
    */
    readonly projectAreaId?: number
    
}

/**
 * Request parameters for clockOut operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiClockOutRequest
 */
export type TimesheetsApiClockOutRequest = {
    
    /**
    * clock out outside geofence
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly proceedOutsideGeoFence?: number
    
    /**
    * Description of timecard.
    * @type {string}
    * @memberof TimesheetsApiClockOut
    */
    readonly description?: string
    
    /**
    * Project ID of project.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly projectId?: number
    
    /**
    * Project Manager corresponding user.
    * @type {string}
    * @memberof TimesheetsApiClockOut
    */
    readonly projectManager?: string
    
    /**
    * Category of timecard. Choose between [\"Regular\", \"Overtime\"].
    * @type {'RG' | 'OT'}
    * @memberof TimesheetsApiClockOut
    */
    readonly categoryCode?: 'RG' | 'OT'
    
    /**
    * Notes.
    * @type {string}
    * @memberof TimesheetsApiClockOut
    */
    readonly notes?: string
    
    /**
    * Billable or non- billable timecard. Select \'Y\' for billable and \'N\' for non-billable
    * @type {'Y' | 'N'}
    * @memberof TimesheetsApiClockOut
    */
    readonly billable?: 'Y' | 'N'
    
    /**
    * Activity type of timecard.
    * @type {string}
    * @memberof TimesheetsApiClockOut
    */
    readonly activity?: string
    
    /**
    * Reason for approval rejection.
    * @type {string}
    * @memberof TimesheetsApiClockOut
    */
    readonly approvalRejectionReason?: string
    
    /**
    * Longitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly clockInLongitude?: number
    
    /**
    * Latitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly clockInLatitude?: number
    
    /**
    * Longitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly clockOutLongitude?: number
    
    /**
    * Latitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly clockOutLatitude?: number
    
    /**
    * Project area ID of project area.
    * @type {number}
    * @memberof TimesheetsApiClockOut
    */
    readonly projectAreaId?: number
    
}

/**
 * Request parameters for createOrUpdateTimesheet operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiCreateOrUpdateTimesheetRequest
 */
export type TimesheetsApiCreateOrUpdateTimesheetRequest = {
    
    /**
    * Timesheet date.
    * @type {string | Date}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly date: string | Date
    
    /**
    * Project ID of project.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly projectId: number
    
    /**
    * Elapsed Time of timecard.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly elapsedTime: string
    
    /**
    * Timecard Id of timecard.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly cardId?: number
    
    /**
    * Description of timecard.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly description?: string
    
    /**
    * Clocked in or clocked out outside geofence.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly clockedOutsideGeofence?: number
    
    /**
    * Project Manager corresponding user.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly projectManager?: string
    
    /**
    * Category of timecard. Choose between [\"Regular\", \"Overtime\"].
    * @type {'RG' | 'OT'}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly categoryCode?: 'RG' | 'OT'
    
    /**
    * Notes.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly notes?: string
    
    /**
    * Billable or non- billable timecard. Select \'Y\' for billable and \'N\' for non-billable
    * @type {'Y' | 'N'}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly billable?: 'Y' | 'N'
    
    /**
    * Activity type of timecard.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly activity?: string
    
    /**
    * Reason for approval rejection.
    * @type {string}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly approvalRejectionReason?: string
    
    /**
    * Longitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly clockInLongitude?: number
    
    /**
    * Latitude value while clocking in.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly clockInLatitude?: number
    
    /**
    * Longitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly clockOutLongitude?: number
    
    /**
    * Latitude value while clocking out.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly clockOutLatitude?: number
    
    /**
    * Project area ID of project area.
    * @type {number}
    * @memberof TimesheetsApiCreateOrUpdateTimesheet
    */
    readonly projectAreaId?: number
    
}

/**
 * Request parameters for deleteByTimesheetId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiDeleteByTimesheetIdRequest
 */
export type TimesheetsApiDeleteByTimesheetIdRequest = {
    
    /**
    * Timesheet ID of timesheet.
    * @type {number}
    * @memberof TimesheetsApiDeleteByTimesheetId
    */
    readonly timesheetId: number
    
}

/**
 * Request parameters for getApprovalList operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiGetApprovalListRequest
 */
export type TimesheetsApiGetApprovalListRequest = {
    
    /**
    * Start date of the timesheet.
    * @type {string}
    * @memberof TimesheetsApiGetApprovalList
    */
    readonly startDate: string
    
    /**
    * End date of the timesheet.
    * @type {string}
    * @memberof TimesheetsApiGetApprovalList
    */
    readonly endDate: string
    
}

/**
 * Request parameters for getByTimesheetId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiGetByTimesheetIdRequest
 */
export type TimesheetsApiGetByTimesheetIdRequest = {
    
    /**
    * Tmesheet ID of timesheet.
    * @type {number}
    * @memberof TimesheetsApiGetByTimesheetId
    */
    readonly timesheetId: number
    
}

/**
 * Request parameters for getByUserId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiGetByUserIdRequest
 */
export type TimesheetsApiGetByUserIdRequest = {
    
    /**
    * Start date of the timesheet.
    * @type {string}
    * @memberof TimesheetsApiGetByUserId
    */
    readonly startDate?: string
    
    /**
    * End date of the timesheet.
    * @type {string}
    * @memberof TimesheetsApiGetByUserId
    */
    readonly endDate?: string
    
}

/**
 * Request parameters for getDetailsByTimesheetId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiGetDetailsByTimesheetIdRequest
 */
export type TimesheetsApiGetDetailsByTimesheetIdRequest = {
    
    /**
    * Timesheet ID of timesheet.
    * @type {number}
    * @memberof TimesheetsApiGetDetailsByTimesheetId
    */
    readonly timeSheetId: number
    
    /**
    * 
    * @type {boolean}
    * @memberof TimesheetsApiGetDetailsByTimesheetId
    */
    readonly flatcustomfields?: boolean
    
}

/**
 * Request parameters for getTimecardsByTimesheetId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiGetTimecardsByTimesheetIdRequest
 */
export type TimesheetsApiGetTimecardsByTimesheetIdRequest = {
    
    /**
    * Start date of the timesheet.
    * @type {string | Date}
    * @memberof TimesheetsApiGetTimecardsByTimesheetId
    */
    readonly startDate: string | Date
    
    /**
    * End date of the timesheet.
    * @type {string | Date}
    * @memberof TimesheetsApiGetTimecardsByTimesheetId
    */
    readonly endDate: string | Date
    
}

/**
 * Request parameters for updateStatusByTimesheetId operation in TimesheetsApi.
 * @export
 * @interface TimesheetsApiUpdateStatusByTimesheetIdRequest
 */
export type TimesheetsApiUpdateStatusByTimesheetIdRequest = {
    
    /**
    * Timesheet ID of the timesheet.
    * @type {number}
    * @memberof TimesheetsApiUpdateStatusByTimesheetId
    */
    readonly timesheetId: number
    
    /**
    * Status of timecard. Choose between [\"PD-Pending for Approval\", \"PAP-Partially Approved\", \"AP-Fully Approved\",\"NEW-New Timesheet\",\"RJ-Rejected\"].
    * @type {'PD' | 'PAP' | 'AP' | 'NEW' | 'RJ'}
    * @memberof TimesheetsApiUpdateStatusByTimesheetId
    */
    readonly status: 'PD' | 'PAP' | 'AP' | 'NEW' | 'RJ'
    
    /**
    * Comments
    * @type {string}
    * @memberof TimesheetsApiUpdateStatusByTimesheetId
    */
    readonly comments?: string
    
}

/**
 * TimesheetsApiGenerated - object-oriented interface
 * @export
 * @class TimesheetsApiGenerated
 * @extends {BaseAPI}
 */
export class TimesheetsApiGenerated extends BaseAPI {
    /**
     * Allows to clock in.
     * @summary Clock in.
     * @param {TimesheetsApiClockInRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public clockIn(requestParameters: TimesheetsApiClockInRequest = {}, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).clockIn(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows user to clock out.
     * @summary Clock out.
     * @param {TimesheetsApiClockOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public clockOut(requestParameters: TimesheetsApiClockOutRequest = {}, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).clockOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new timesheet and update existing timesheet.
     * @summary Create/Update a timesheet.
     * @param {TimesheetsApiCreateOrUpdateTimesheetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public createOrUpdateTimesheet(requestParameters: TimesheetsApiCreateOrUpdateTimesheetRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).createOrUpdateTimesheet(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a timesheet by Timesheet ID.
     * @summary Delete a timesheet.
     * @param {TimesheetsApiDeleteByTimesheetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public deleteByTimesheetId(requestParameters: TimesheetsApiDeleteByTimesheetIdRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).deleteByTimesheetId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of active allocations of user.
     * @summary Retrieve my active allocations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getActiveAllocations(options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getActiveAllocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of timesheet approvals on the basis of permission.
     * @summary Retrieve timesheet approvals.
     * @param {TimesheetsApiGetApprovalListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getApprovalList(requestParameters: TimesheetsApiGetApprovalListRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getApprovalList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a timesheet by timesheet ID.
     * @summary Retrieve a timesheet by timesheet ID.
     * @param {TimesheetsApiGetByTimesheetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getByTimesheetId(requestParameters: TimesheetsApiGetByTimesheetIdRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getByTimesheetId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of timesheets.
     * @summary Retrieve timesheets by User ID.
     * @param {TimesheetsApiGetByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getByUserId(requestParameters: TimesheetsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve timesheet details by Timesheet ID.
     * @summary Retrieve timesheet details by Timesheet ID.
     * @param {TimesheetsApiGetDetailsByTimesheetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getDetailsByTimesheetId(requestParameters: TimesheetsApiGetDetailsByTimesheetIdRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getDetailsByTimesheetId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of timesheet preferences based in cid.
     * @summary Retrieve my timesheet preferences.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getPreferencesByCid(options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getPreferencesByCid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of timecards.
     * @summary Retrieve timecards by Timesheet ID.
     * @param {TimesheetsApiGetTimecardsByTimesheetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public getTimecardsByTimesheetId(requestParameters: TimesheetsApiGetTimecardsByTimesheetIdRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).getTimecardsByTimesheetId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of activity types based on cid.
     * @summary Retrieve list of activity types based on cid.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public listActivityTypesByCid(options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).listActivityTypesByCid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the timesheet status (submit, approve, reject) corresponding to supplied Timesheet ID.
     * @summary Update timesheet status by Timesheet ID.
     * @param {TimesheetsApiUpdateStatusByTimesheetIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimesheetsApiGenerated
     */
    public updateStatusByTimesheetId(requestParameters: TimesheetsApiUpdateStatusByTimesheetIdRequest, options?: AxiosRequestConfig) {
        return TimesheetsApiFp(this.configuration).updateStatusByTimesheetId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
