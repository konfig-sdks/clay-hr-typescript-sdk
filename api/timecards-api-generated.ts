/* tslint:disable */
/* eslint-disable */
/*
Expense Reports

API Documentation

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { TimecardsGetByUserId200Response } from '../models';
// @ts-ignore
import { TimecardsGetDetailsByTimecardId403Response } from '../models';
// @ts-ignore
import { TimecardsGetDetailsByTimecardId404Response } from '../models';
// @ts-ignore
import { TimecardsGetDetailsByTimecardId409Response } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TimecardsApi - axios parameter creator
 * @export
 */
export const TimecardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clock Out
         * @param {string} authorization Authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('clockOut', 'authorization', authorization)
            const localVarPath = `/timecard/clock/out`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timecard/clock/out',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a past timecard.
         * @param {string} authorization Authorization
         * @param {string} [activity] 
         * @param {number} [amount] 
         * @param {string} [approvalRejectionReason] 
         * @param {string} [billable] 
         * @param {number} [cardId] 
         * @param {string} [caseNum] 
         * @param {string} [caseURL] 
         * @param {string} [categoryCode] 
         * @param {string} [chargeType] 
         * @param {number} [cid] 
         * @param {number} [createUserID] 
         * @param {number} [createtsDate] 
         * @param {number} [createtsDay] 
         * @param {number} [createtsHours] 
         * @param {number} [createtsMinutes] 
         * @param {number} [createtsMonth] 
         * @param {number} [createtsNanos] 
         * @param {number} [createtsSeconds] 
         * @param {number} [createtsTime] 
         * @param {number} [createtsTimezoneOffset] 
         * @param {number} [createtsYear] 
         * @param {string} [customHours] 
         * @param {string | Date} [date] 
         * @param {string} [description] 
         * @param {number} [elapsedTimeDate] 
         * @param {number} [elapsedTimeDay] 
         * @param {number} [elapsedTimeHours] 
         * @param {number} [elapsedTimeMinutes] 
         * @param {number} [elapsedTimeMonth] 
         * @param {number} [elapsedTimeSeconds] 
         * @param {number} [elapsedTimeTime] 
         * @param {number} [elapsedTimeTimezoneOffset] 
         * @param {number} [elapsedTimeYear] 
         * @param {number} [endDateTimeDate] 
         * @param {number} [endDateTimeDay] 
         * @param {number} [endDateTimeHours] 
         * @param {number} [endDateTimeMinutes] 
         * @param {number} [endDateTimeMonth] 
         * @param {number} [endDateTimeNanos] 
         * @param {number} [endDateTimeSeconds] 
         * @param {number} [endDateTimeTime] 
         * @param {number} [endDateTimeTimezoneOffset] 
         * @param {number} [endDateTimeYear] 
         * @param {string} [endDateTimeStr] 
         * @param {number} [id] 
         * @param {number} [invoiceId] 
         * @param {string} [notes] 
         * @param {number} [numberOfDays] 
         * @param {string | Date} [paymentDate] 
         * @param {number} [projectId] 
         * @param {string} [projectManager] 
         * @param {number} [projectModelAccount] 
         * @param {string} [ptoComputed] 
         * @param {string} [source] 
         * @param {number} [startDateTimeDate] 
         * @param {number} [startDateTimeDay] 
         * @param {number} [startDateTimeHours] 
         * @param {number} [startDateTimeMinutes] 
         * @param {number} [startDateTimeMonth] 
         * @param {number} [startDateTimeNanos] 
         * @param {number} [startDateTimeSeconds] 
         * @param {number} [startDateTimeTime] 
         * @param {number} [startDateTimeTimezoneOffset] 
         * @param {number} [startDateTimeYear] 
         * @param {string} [startDateTimeStr] 
         * @param {string} [status] 
         * @param {string} [sumOfElapsedTime] 
         * @param {number} [timesheetId] 
         * @param {string} [timezone] 
         * @param {number} [usedTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPastTimecard: async (authorization: string, activity?: string, amount?: number, approvalRejectionReason?: string, billable?: string, cardId?: number, caseNum?: string, caseURL?: string, categoryCode?: string, chargeType?: string, cid?: number, createUserID?: number, createtsDate?: number, createtsDay?: number, createtsHours?: number, createtsMinutes?: number, createtsMonth?: number, createtsNanos?: number, createtsSeconds?: number, createtsTime?: number, createtsTimezoneOffset?: number, createtsYear?: number, customHours?: string, date?: string | Date, description?: string, elapsedTimeDate?: number, elapsedTimeDay?: number, elapsedTimeHours?: number, elapsedTimeMinutes?: number, elapsedTimeMonth?: number, elapsedTimeSeconds?: number, elapsedTimeTime?: number, elapsedTimeTimezoneOffset?: number, elapsedTimeYear?: number, endDateTimeDate?: number, endDateTimeDay?: number, endDateTimeHours?: number, endDateTimeMinutes?: number, endDateTimeMonth?: number, endDateTimeNanos?: number, endDateTimeSeconds?: number, endDateTimeTime?: number, endDateTimeTimezoneOffset?: number, endDateTimeYear?: number, endDateTimeStr?: string, id?: number, invoiceId?: number, notes?: string, numberOfDays?: number, paymentDate?: string | Date, projectId?: number, projectManager?: string, projectModelAccount?: number, ptoComputed?: string, source?: string, startDateTimeDate?: number, startDateTimeDay?: number, startDateTimeHours?: number, startDateTimeMinutes?: number, startDateTimeMonth?: number, startDateTimeNanos?: number, startDateTimeSeconds?: number, startDateTimeTime?: number, startDateTimeTimezoneOffset?: number, startDateTimeYear?: number, startDateTimeStr?: string, status?: string, sumOfElapsedTime?: string, timesheetId?: number, timezone?: string, usedTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('createPastTimecard', 'authorization', authorization)
            const localVarPath = `/timecard/clockin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (activity !== undefined) {
                localVarQueryParameter['activity'] = activity;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (approvalRejectionReason !== undefined) {
                localVarQueryParameter['approvalRejectionReason'] = approvalRejectionReason;
            }

            if (billable !== undefined) {
                localVarQueryParameter['billable'] = billable;
            }

            if (cardId !== undefined) {
                localVarQueryParameter['cardId'] = cardId;
            }

            if (caseNum !== undefined) {
                localVarQueryParameter['caseNum'] = caseNum;
            }

            if (caseURL !== undefined) {
                localVarQueryParameter['caseURL'] = caseURL;
            }

            if (categoryCode !== undefined) {
                localVarQueryParameter['categoryCode'] = categoryCode;
            }

            if (chargeType !== undefined) {
                localVarQueryParameter['chargeType'] = chargeType;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }

            if (createUserID !== undefined) {
                localVarQueryParameter['createUserID'] = createUserID;
            }

            if (createtsDate !== undefined) {
                localVarQueryParameter['createts.date'] = createtsDate;
            }

            if (createtsDay !== undefined) {
                localVarQueryParameter['createts.day'] = createtsDay;
            }

            if (createtsHours !== undefined) {
                localVarQueryParameter['createts.hours'] = createtsHours;
            }

            if (createtsMinutes !== undefined) {
                localVarQueryParameter['createts.minutes'] = createtsMinutes;
            }

            if (createtsMonth !== undefined) {
                localVarQueryParameter['createts.month'] = createtsMonth;
            }

            if (createtsNanos !== undefined) {
                localVarQueryParameter['createts.nanos'] = createtsNanos;
            }

            if (createtsSeconds !== undefined) {
                localVarQueryParameter['createts.seconds'] = createtsSeconds;
            }

            if (createtsTime !== undefined) {
                localVarQueryParameter['createts.time'] = createtsTime;
            }

            if (createtsTimezoneOffset !== undefined) {
                localVarQueryParameter['createts.timezoneOffset'] = createtsTimezoneOffset;
            }

            if (createtsYear !== undefined) {
                localVarQueryParameter['createts.year'] = createtsYear;
            }

            if (customHours !== undefined) {
                localVarQueryParameter['customHours'] = customHours;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (elapsedTimeDate !== undefined) {
                localVarQueryParameter['elapsedTime.date'] = elapsedTimeDate;
            }

            if (elapsedTimeDay !== undefined) {
                localVarQueryParameter['elapsedTime.day'] = elapsedTimeDay;
            }

            if (elapsedTimeHours !== undefined) {
                localVarQueryParameter['elapsedTime.hours'] = elapsedTimeHours;
            }

            if (elapsedTimeMinutes !== undefined) {
                localVarQueryParameter['elapsedTime.minutes'] = elapsedTimeMinutes;
            }

            if (elapsedTimeMonth !== undefined) {
                localVarQueryParameter['elapsedTime.month'] = elapsedTimeMonth;
            }

            if (elapsedTimeSeconds !== undefined) {
                localVarQueryParameter['elapsedTime.seconds'] = elapsedTimeSeconds;
            }

            if (elapsedTimeTime !== undefined) {
                localVarQueryParameter['elapsedTime.time'] = elapsedTimeTime;
            }

            if (elapsedTimeTimezoneOffset !== undefined) {
                localVarQueryParameter['elapsedTime.timezoneOffset'] = elapsedTimeTimezoneOffset;
            }

            if (elapsedTimeYear !== undefined) {
                localVarQueryParameter['elapsedTime.year'] = elapsedTimeYear;
            }

            if (endDateTimeDate !== undefined) {
                localVarQueryParameter['endDateTime.date'] = endDateTimeDate;
            }

            if (endDateTimeDay !== undefined) {
                localVarQueryParameter['endDateTime.day'] = endDateTimeDay;
            }

            if (endDateTimeHours !== undefined) {
                localVarQueryParameter['endDateTime.hours'] = endDateTimeHours;
            }

            if (endDateTimeMinutes !== undefined) {
                localVarQueryParameter['endDateTime.minutes'] = endDateTimeMinutes;
            }

            if (endDateTimeMonth !== undefined) {
                localVarQueryParameter['endDateTime.month'] = endDateTimeMonth;
            }

            if (endDateTimeNanos !== undefined) {
                localVarQueryParameter['endDateTime.nanos'] = endDateTimeNanos;
            }

            if (endDateTimeSeconds !== undefined) {
                localVarQueryParameter['endDateTime.seconds'] = endDateTimeSeconds;
            }

            if (endDateTimeTime !== undefined) {
                localVarQueryParameter['endDateTime.time'] = endDateTimeTime;
            }

            if (endDateTimeTimezoneOffset !== undefined) {
                localVarQueryParameter['endDateTime.timezoneOffset'] = endDateTimeTimezoneOffset;
            }

            if (endDateTimeYear !== undefined) {
                localVarQueryParameter['endDateTime.year'] = endDateTimeYear;
            }

            if (endDateTimeStr !== undefined) {
                localVarQueryParameter['endDateTimeStr'] = endDateTimeStr;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (numberOfDays !== undefined) {
                localVarQueryParameter['numberOfDays'] = numberOfDays;
            }

            if (paymentDate !== undefined) {
                localVarQueryParameter['paymentDate'] = (paymentDate as any instanceof Date) ?
                    (paymentDate as any).toISOString().substr(0,10) :
                    paymentDate;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectManager !== undefined) {
                localVarQueryParameter['projectManager'] = projectManager;
            }

            if (projectModelAccount !== undefined) {
                localVarQueryParameter['projectModel.account'] = projectModelAccount;
            }

            if (ptoComputed !== undefined) {
                localVarQueryParameter['ptoComputed'] = ptoComputed;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (startDateTimeDate !== undefined) {
                localVarQueryParameter['startDateTime.date'] = startDateTimeDate;
            }

            if (startDateTimeDay !== undefined) {
                localVarQueryParameter['startDateTime.day'] = startDateTimeDay;
            }

            if (startDateTimeHours !== undefined) {
                localVarQueryParameter['startDateTime.hours'] = startDateTimeHours;
            }

            if (startDateTimeMinutes !== undefined) {
                localVarQueryParameter['startDateTime.minutes'] = startDateTimeMinutes;
            }

            if (startDateTimeMonth !== undefined) {
                localVarQueryParameter['startDateTime.month'] = startDateTimeMonth;
            }

            if (startDateTimeNanos !== undefined) {
                localVarQueryParameter['startDateTime.nanos'] = startDateTimeNanos;
            }

            if (startDateTimeSeconds !== undefined) {
                localVarQueryParameter['startDateTime.seconds'] = startDateTimeSeconds;
            }

            if (startDateTimeTime !== undefined) {
                localVarQueryParameter['startDateTime.time'] = startDateTimeTime;
            }

            if (startDateTimeTimezoneOffset !== undefined) {
                localVarQueryParameter['startDateTime.timezoneOffset'] = startDateTimeTimezoneOffset;
            }

            if (startDateTimeYear !== undefined) {
                localVarQueryParameter['startDateTime.year'] = startDateTimeYear;
            }

            if (startDateTimeStr !== undefined) {
                localVarQueryParameter['startDateTimeStr'] = startDateTimeStr;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sumOfElapsedTime !== undefined) {
                localVarQueryParameter['sumOfElapsedTime'] = sumOfElapsedTime;
            }

            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (usedTime !== undefined) {
                localVarQueryParameter['usedTime'] = usedTime;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timecard/clockin',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new timecard.
         * @param {number} [createtsDate] 
         * @param {number} [createtsDay] 
         * @param {number} [createtsHours] 
         * @param {number} [createtsMinutes] 
         * @param {number} [createtsMonth] 
         * @param {number} [createtsNanos] 
         * @param {number} [createtsSeconds] 
         * @param {number} [createtsTime] 
         * @param {number} [createtsTimezoneOffset] 
         * @param {number} [createtsYear] 
         * @param {string} [customHours] 
         * @param {string | Date} [date] 
         * @param {string} [description] 
         * @param {number} [elapsedTimeDate] 
         * @param {number} [elapsedTimeDay] 
         * @param {number} [elapsedTimeHours] 
         * @param {number} [elapsedTimeMinutes] 
         * @param {number} [elapsedTimeMonth] 
         * @param {number} [elapsedTimeSeconds] 
         * @param {number} [elapsedTimeTime] 
         * @param {number} [elapsedTimeTimezoneOffset] 
         * @param {number} [elapsedTimeYear] 
         * @param {number} [endDateTimeDate] 
         * @param {number} [endDateTimeDay] 
         * @param {number} [endDateTimeHours] 
         * @param {number} [endDateTimeMinutes] 
         * @param {number} [endDateTimeMonth] 
         * @param {number} [endDateTimeNanos] 
         * @param {number} [endDateTimeSeconds] 
         * @param {number} [endDateTimeTime] 
         * @param {number} [endDateTimeTimezoneOffset] 
         * @param {number} [endDateTimeYear] 
         * @param {string} [endDateTimeStr] 
         * @param {number} [id] 
         * @param {number} [invoiceId] 
         * @param {string} [notes] 
         * @param {number} [numberOfDays] 
         * @param {string | Date} [paymentDate] 
         * @param {number} [projectId] 
         * @param {string} [projectManager] 
         * @param {number} [projectModelAccount] 
         * @param {number} [timesheetId] 
         * @param {string} [timezone] 
         * @param {number} [usedTime] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimecard: async (createtsDate?: number, createtsDay?: number, createtsHours?: number, createtsMinutes?: number, createtsMonth?: number, createtsNanos?: number, createtsSeconds?: number, createtsTime?: number, createtsTimezoneOffset?: number, createtsYear?: number, customHours?: string, date?: string | Date, description?: string, elapsedTimeDate?: number, elapsedTimeDay?: number, elapsedTimeHours?: number, elapsedTimeMinutes?: number, elapsedTimeMonth?: number, elapsedTimeSeconds?: number, elapsedTimeTime?: number, elapsedTimeTimezoneOffset?: number, elapsedTimeYear?: number, endDateTimeDate?: number, endDateTimeDay?: number, endDateTimeHours?: number, endDateTimeMinutes?: number, endDateTimeMonth?: number, endDateTimeNanos?: number, endDateTimeSeconds?: number, endDateTimeTime?: number, endDateTimeTimezoneOffset?: number, endDateTimeYear?: number, endDateTimeStr?: string, id?: number, invoiceId?: number, notes?: string, numberOfDays?: number, paymentDate?: string | Date, projectId?: number, projectManager?: string, projectModelAccount?: number, timesheetId?: number, timezone?: string, usedTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timecard/addtimecard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (createtsDate !== undefined) {
                localVarQueryParameter['createts.date'] = createtsDate;
            }

            if (createtsDay !== undefined) {
                localVarQueryParameter['createts.day'] = createtsDay;
            }

            if (createtsHours !== undefined) {
                localVarQueryParameter['createts.hours'] = createtsHours;
            }

            if (createtsMinutes !== undefined) {
                localVarQueryParameter['createts.minutes'] = createtsMinutes;
            }

            if (createtsMonth !== undefined) {
                localVarQueryParameter['createts.month'] = createtsMonth;
            }

            if (createtsNanos !== undefined) {
                localVarQueryParameter['createts.nanos'] = createtsNanos;
            }

            if (createtsSeconds !== undefined) {
                localVarQueryParameter['createts.seconds'] = createtsSeconds;
            }

            if (createtsTime !== undefined) {
                localVarQueryParameter['createts.time'] = createtsTime;
            }

            if (createtsTimezoneOffset !== undefined) {
                localVarQueryParameter['createts.timezoneOffset'] = createtsTimezoneOffset;
            }

            if (createtsYear !== undefined) {
                localVarQueryParameter['createts.year'] = createtsYear;
            }

            if (customHours !== undefined) {
                localVarQueryParameter['customHours'] = customHours;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (elapsedTimeDate !== undefined) {
                localVarQueryParameter['elapsedTime.date'] = elapsedTimeDate;
            }

            if (elapsedTimeDay !== undefined) {
                localVarQueryParameter['elapsedTime.day'] = elapsedTimeDay;
            }

            if (elapsedTimeHours !== undefined) {
                localVarQueryParameter['elapsedTime.hours'] = elapsedTimeHours;
            }

            if (elapsedTimeMinutes !== undefined) {
                localVarQueryParameter['elapsedTime.minutes'] = elapsedTimeMinutes;
            }

            if (elapsedTimeMonth !== undefined) {
                localVarQueryParameter['elapsedTime.month'] = elapsedTimeMonth;
            }

            if (elapsedTimeSeconds !== undefined) {
                localVarQueryParameter['elapsedTime.seconds'] = elapsedTimeSeconds;
            }

            if (elapsedTimeTime !== undefined) {
                localVarQueryParameter['elapsedTime.time'] = elapsedTimeTime;
            }

            if (elapsedTimeTimezoneOffset !== undefined) {
                localVarQueryParameter['elapsedTime.timezoneOffset'] = elapsedTimeTimezoneOffset;
            }

            if (elapsedTimeYear !== undefined) {
                localVarQueryParameter['elapsedTime.year'] = elapsedTimeYear;
            }

            if (endDateTimeDate !== undefined) {
                localVarQueryParameter['endDateTime.date'] = endDateTimeDate;
            }

            if (endDateTimeDay !== undefined) {
                localVarQueryParameter['endDateTime.day'] = endDateTimeDay;
            }

            if (endDateTimeHours !== undefined) {
                localVarQueryParameter['endDateTime.hours'] = endDateTimeHours;
            }

            if (endDateTimeMinutes !== undefined) {
                localVarQueryParameter['endDateTime.minutes'] = endDateTimeMinutes;
            }

            if (endDateTimeMonth !== undefined) {
                localVarQueryParameter['endDateTime.month'] = endDateTimeMonth;
            }

            if (endDateTimeNanos !== undefined) {
                localVarQueryParameter['endDateTime.nanos'] = endDateTimeNanos;
            }

            if (endDateTimeSeconds !== undefined) {
                localVarQueryParameter['endDateTime.seconds'] = endDateTimeSeconds;
            }

            if (endDateTimeTime !== undefined) {
                localVarQueryParameter['endDateTime.time'] = endDateTimeTime;
            }

            if (endDateTimeTimezoneOffset !== undefined) {
                localVarQueryParameter['endDateTime.timezoneOffset'] = endDateTimeTimezoneOffset;
            }

            if (endDateTimeYear !== undefined) {
                localVarQueryParameter['endDateTime.year'] = endDateTimeYear;
            }

            if (endDateTimeStr !== undefined) {
                localVarQueryParameter['endDateTimeStr'] = endDateTimeStr;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoiceId'] = invoiceId;
            }

            if (notes !== undefined) {
                localVarQueryParameter['notes'] = notes;
            }

            if (numberOfDays !== undefined) {
                localVarQueryParameter['numberOfDays'] = numberOfDays;
            }

            if (paymentDate !== undefined) {
                localVarQueryParameter['paymentDate'] = (paymentDate as any instanceof Date) ?
                    (paymentDate as any).toISOString().substr(0,10) :
                    paymentDate;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (projectManager !== undefined) {
                localVarQueryParameter['projectManager'] = projectManager;
            }

            if (projectModelAccount !== undefined) {
                localVarQueryParameter['projectModel.account'] = projectModelAccount;
            }

            if (timesheetId !== undefined) {
                localVarQueryParameter['timesheetId'] = timesheetId;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (usedTime !== undefined) {
                localVarQueryParameter['usedTime'] = usedTime;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timecard/addtimecard',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve timecard details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details by User ID.
         * @param {string} [email] email of the user.
         * @param {string} [guid] Graphical user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId: async (email?: string, guid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/timecard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/user/timecard',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve timecard basic details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard basic details by User ID.
         * @param {string} [email] email of the user.
         * @param {string} [guid] Graphical user ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId_1: async (email?: string, guid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/timecards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (guid !== undefined) {
                localVarQueryParameter['guid'] = guid;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/user/timecards',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve timecard details based on timecard ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details based on timecard ID.
         * @param {number} timecardId Timecard ID of the timecard.
         * @param {boolean} [flatcustomfields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsByTimecardId: async (timecardId: number, flatcustomfields?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timecardId' is not null or undefined
            assertParamExists('getDetailsByTimecardId', 'timecardId', timecardId)
            const localVarPath = `/api/timecards/details/{timecardId}`
                .replace(`{${"timecardId"}}`, encodeURIComponent(String(timecardId !== undefined ? timecardId : `-timecardId-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec0 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "x-api-key", keyParamName: "sec0", configuration })
            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (flatcustomfields !== undefined) {
                localVarQueryParameter['flatcustomfields'] = flatcustomfields;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/api/timecards/details/{timecardId}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TVC code for clockin with QR Code using cid.
         * @param {number} cid cid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVCForClockinWithQRCodeUsingCid: async (cid: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('getTVCForClockinWithQRCodeUsingCid', 'cid', cid)
            const localVarPath = `/verify/tvc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/verify/tvc',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get timecards by user id.
         * @param {string} authorization Authorization
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (authorization: string, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getUserById', 'authorization', authorization)
            const localVarPath = `/timecard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/timecard',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register device for ClockIn with AssetModel.
         * @param {string} [accessories] 
         * @param {number} [acknowledge] 
         * @param {number} [assetID] 
         * @param {string} [assetno] 
         * @param {string} [assetstatus] 
         * @param {string} [assettype] 
         * @param {string | Date} [purchaseDate] 
         * @param {number} [selfAssign] 
         * @param {string} [serialno] 
         * @param {string} [service] 
         * @param {string} [source] 
         * @param {string} [specs] 
         * @param {string} [supplier] 
         * @param {string} [useStatusCode] 
         * @param {string} [userDomain] 
         * @param {string} [userMail] 
         * @param {string} [userPassword] 
         * @param {string} [uuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDeviceForClockInWithAssetModel: async (accessories?: string, acknowledge?: number, assetID?: number, assetno?: string, assetstatus?: string, assettype?: string, purchaseDate?: string | Date, selfAssign?: number, serialno?: string, service?: string, source?: string, specs?: string, supplier?: string, useStatusCode?: string, userDomain?: string, userMail?: string, userPassword?: string, uuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (accessories !== undefined) {
                localVarQueryParameter['accessories'] = accessories;
            }

            if (acknowledge !== undefined) {
                localVarQueryParameter['acknowledge'] = acknowledge;
            }

            if (assetID !== undefined) {
                localVarQueryParameter['assetID'] = assetID;
            }

            if (assetno !== undefined) {
                localVarQueryParameter['assetno'] = assetno;
            }

            if (assetstatus !== undefined) {
                localVarQueryParameter['assetstatus'] = assetstatus;
            }

            if (assettype !== undefined) {
                localVarQueryParameter['assettype'] = assettype;
            }

            if (purchaseDate !== undefined) {
                localVarQueryParameter['purchaseDate'] = (purchaseDate as any instanceof Date) ?
                    (purchaseDate as any).toISOString().substr(0,10) :
                    purchaseDate;
            }

            if (selfAssign !== undefined) {
                localVarQueryParameter['selfAssign'] = selfAssign;
            }

            if (serialno !== undefined) {
                localVarQueryParameter['serialno'] = serialno;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (specs !== undefined) {
                localVarQueryParameter['specs'] = specs;
            }

            if (supplier !== undefined) {
                localVarQueryParameter['supplier'] = supplier;
            }

            if (useStatusCode !== undefined) {
                localVarQueryParameter['useStatusCode'] = useStatusCode;
            }

            if (userDomain !== undefined) {
                localVarQueryParameter['userDomain'] = userDomain;
            }

            if (userMail !== undefined) {
                localVarQueryParameter['userMail'] = userMail;
            }

            if (userPassword !== undefined) {
                localVarQueryParameter['userPassword'] = userPassword;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/register',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Device verification with DeviceUUID.
         * @param {string} deviceUUID deviceUUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDeviceWithDeviceUUID: async (deviceUUID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceUUID' is not null or undefined
            assertParamExists('verifyDeviceWithDeviceUUID', 'deviceUUID', deviceUUID)
            const localVarPath = `/verify/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceUUID !== undefined) {
                localVarQueryParameter['deviceUUID'] = deviceUUID;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/verify/device',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User verification with userid.
         * @param {string} [adpAssociateOID] 
         * @param {number} [allocation] 
         * @param {string} [appleUserIdentifier] 
         * @param {string} [assignments] 
         * @param {string} [authToken] 
         * @param {string} [calWeekPref] 
         * @param {number} [calendarId] 
         * @param {number} [candidateId] 
         * @param {number} [careerPathwayId] 
         * @param {string} [cellPhone] 
         * @param {number} [cid] 
         * @param {number} [countryId] 
         * @param {number} [createtsDate] 
         * @param {number} [createtsDay] 
         * @param {number} [createtsHours] 
         * @param {number} [createtsMinutes] 
         * @param {number} [createtsMonth] 
         * @param {number} [createtsNanos] 
         * @param {number} [createtsSeconds] 
         * @param {number} [createtsTime] 
         * @param {number} [createtsTimezoneOffset] 
         * @param {number} [createtsYear] 
         * @param {number} [createuserid] 
         * @param {string} [thumbnail] 
         * @param {string} [timecardPeriodPref] 
         * @param {string} [timezone] 
         * @param {string} [tosVersion] 
         * @param {string} [userCountry] 
         * @param {string} [userDateFormat] 
         * @param {string | Date} [userDateOfBirth] 
         * @param {string} [userDisplayName] 
         * @param {string | Date} [userEndDate] 
         * @param {string} [userName] 
         * @param {string} [userNameFormat] 
         * @param {string} [userType] 
         * @param {boolean} [view] 
         * @param {string} [workerType] 
         * @param {string} [workingDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserWithUserid: async (adpAssociateOID?: string, allocation?: number, appleUserIdentifier?: string, assignments?: string, authToken?: string, calWeekPref?: string, calendarId?: number, candidateId?: number, careerPathwayId?: number, cellPhone?: string, cid?: number, countryId?: number, createtsDate?: number, createtsDay?: number, createtsHours?: number, createtsMinutes?: number, createtsMonth?: number, createtsNanos?: number, createtsSeconds?: number, createtsTime?: number, createtsTimezoneOffset?: number, createtsYear?: number, createuserid?: number, thumbnail?: string, timecardPeriodPref?: string, timezone?: string, tosVersion?: string, userCountry?: string, userDateFormat?: string, userDateOfBirth?: string | Date, userDisplayName?: string, userEndDate?: string | Date, userName?: string, userNameFormat?: string, userType?: string, view?: boolean, workerType?: string, workingDays?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/verify/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sec1 required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "userid", keyParamName: "sec1", configuration })
            if (adpAssociateOID !== undefined) {
                localVarQueryParameter['adpAssociateOID'] = adpAssociateOID;
            }

            if (allocation !== undefined) {
                localVarQueryParameter['allocation'] = allocation;
            }

            if (appleUserIdentifier !== undefined) {
                localVarQueryParameter['appleUserIdentifier'] = appleUserIdentifier;
            }

            if (assignments !== undefined) {
                localVarQueryParameter['assignments'] = assignments;
            }

            if (authToken !== undefined) {
                localVarQueryParameter['authToken'] = authToken;
            }

            if (calWeekPref !== undefined) {
                localVarQueryParameter['calWeekPref'] = calWeekPref;
            }

            if (calendarId !== undefined) {
                localVarQueryParameter['calendarId'] = calendarId;
            }

            if (candidateId !== undefined) {
                localVarQueryParameter['candidateId'] = candidateId;
            }

            if (careerPathwayId !== undefined) {
                localVarQueryParameter['careerPathwayId'] = careerPathwayId;
            }

            if (cellPhone !== undefined) {
                localVarQueryParameter['cellPhone'] = cellPhone;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }

            if (countryId !== undefined) {
                localVarQueryParameter['countryId'] = countryId;
            }

            if (createtsDate !== undefined) {
                localVarQueryParameter['createts.date'] = createtsDate;
            }

            if (createtsDay !== undefined) {
                localVarQueryParameter['createts.day'] = createtsDay;
            }

            if (createtsHours !== undefined) {
                localVarQueryParameter['createts.hours'] = createtsHours;
            }

            if (createtsMinutes !== undefined) {
                localVarQueryParameter['createts.minutes'] = createtsMinutes;
            }

            if (createtsMonth !== undefined) {
                localVarQueryParameter['createts.month'] = createtsMonth;
            }

            if (createtsNanos !== undefined) {
                localVarQueryParameter['createts.nanos'] = createtsNanos;
            }

            if (createtsSeconds !== undefined) {
                localVarQueryParameter['createts.seconds'] = createtsSeconds;
            }

            if (createtsTime !== undefined) {
                localVarQueryParameter['createts.time'] = createtsTime;
            }

            if (createtsTimezoneOffset !== undefined) {
                localVarQueryParameter['createts.timezoneOffset'] = createtsTimezoneOffset;
            }

            if (createtsYear !== undefined) {
                localVarQueryParameter['createts.year'] = createtsYear;
            }

            if (createuserid !== undefined) {
                localVarQueryParameter['createuserid'] = createuserid;
            }

            if (thumbnail !== undefined) {
                localVarQueryParameter['thumbnail'] = thumbnail;
            }

            if (timecardPeriodPref !== undefined) {
                localVarQueryParameter['timecardPeriodPref'] = timecardPeriodPref;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (tosVersion !== undefined) {
                localVarQueryParameter['tosVersion'] = tosVersion;
            }

            if (userCountry !== undefined) {
                localVarQueryParameter['userCountry'] = userCountry;
            }

            if (userDateFormat !== undefined) {
                localVarQueryParameter['userDateFormat'] = userDateFormat;
            }

            if (userDateOfBirth !== undefined) {
                localVarQueryParameter['userDateOfBirth'] = (userDateOfBirth as any instanceof Date) ?
                    (userDateOfBirth as any).toISOString().substr(0,10) :
                    userDateOfBirth;
            }

            if (userDisplayName !== undefined) {
                localVarQueryParameter['userDisplayName'] = userDisplayName;
            }

            if (userEndDate !== undefined) {
                localVarQueryParameter['userEndDate'] = (userEndDate as any instanceof Date) ?
                    (userEndDate as any).toISOString().substr(0,10) :
                    userEndDate;
            }

            if (userName !== undefined) {
                localVarQueryParameter['userName'] = userName;
            }

            if (userNameFormat !== undefined) {
                localVarQueryParameter['userNameFormat'] = userNameFormat;
            }

            if (userType !== undefined) {
                localVarQueryParameter['userType'] = userType;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (workerType !== undefined) {
                localVarQueryParameter['workerType'] = workerType;
            }

            if (workingDays !== undefined) {
                localVarQueryParameter['workingDays'] = workingDays;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/verify/user',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimecardsApi - functional programming interface
 * @export
 */
export const TimecardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimecardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Clock Out
         * @param {TimecardsApiClockOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clockOut(requestParameters: TimecardsApiClockOutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clockOut(requestParameters.authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a past timecard.
         * @param {TimecardsApiCreatePastTimecardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPastTimecard(requestParameters: TimecardsApiCreatePastTimecardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPastTimecard(requestParameters.authorization, requestParameters.activity, requestParameters.amount, requestParameters.approvalRejectionReason, requestParameters.billable, requestParameters.cardId, requestParameters.caseNum, requestParameters.caseURL, requestParameters.categoryCode, requestParameters.chargeType, requestParameters.cid, requestParameters.createUserID, requestParameters.createtsDate, requestParameters.createtsDay, requestParameters.createtsHours, requestParameters.createtsMinutes, requestParameters.createtsMonth, requestParameters.createtsNanos, requestParameters.createtsSeconds, requestParameters.createtsTime, requestParameters.createtsTimezoneOffset, requestParameters.createtsYear, requestParameters.customHours, requestParameters.date, requestParameters.description, requestParameters.elapsedTimeDate, requestParameters.elapsedTimeDay, requestParameters.elapsedTimeHours, requestParameters.elapsedTimeMinutes, requestParameters.elapsedTimeMonth, requestParameters.elapsedTimeSeconds, requestParameters.elapsedTimeTime, requestParameters.elapsedTimeTimezoneOffset, requestParameters.elapsedTimeYear, requestParameters.endDateTimeDate, requestParameters.endDateTimeDay, requestParameters.endDateTimeHours, requestParameters.endDateTimeMinutes, requestParameters.endDateTimeMonth, requestParameters.endDateTimeNanos, requestParameters.endDateTimeSeconds, requestParameters.endDateTimeTime, requestParameters.endDateTimeTimezoneOffset, requestParameters.endDateTimeYear, requestParameters.endDateTimeStr, requestParameters.id, requestParameters.invoiceId, requestParameters.notes, requestParameters.numberOfDays, requestParameters.paymentDate, requestParameters.projectId, requestParameters.projectManager, requestParameters.projectModelAccount, requestParameters.ptoComputed, requestParameters.source, requestParameters.startDateTimeDate, requestParameters.startDateTimeDay, requestParameters.startDateTimeHours, requestParameters.startDateTimeMinutes, requestParameters.startDateTimeMonth, requestParameters.startDateTimeNanos, requestParameters.startDateTimeSeconds, requestParameters.startDateTimeTime, requestParameters.startDateTimeTimezoneOffset, requestParameters.startDateTimeYear, requestParameters.startDateTimeStr, requestParameters.status, requestParameters.sumOfElapsedTime, requestParameters.timesheetId, requestParameters.timezone, requestParameters.usedTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new timecard.
         * @param {TimecardsApiCreateTimecardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimecard(requestParameters: TimecardsApiCreateTimecardRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimecard(requestParameters.createtsDate, requestParameters.createtsDay, requestParameters.createtsHours, requestParameters.createtsMinutes, requestParameters.createtsMonth, requestParameters.createtsNanos, requestParameters.createtsSeconds, requestParameters.createtsTime, requestParameters.createtsTimezoneOffset, requestParameters.createtsYear, requestParameters.customHours, requestParameters.date, requestParameters.description, requestParameters.elapsedTimeDate, requestParameters.elapsedTimeDay, requestParameters.elapsedTimeHours, requestParameters.elapsedTimeMinutes, requestParameters.elapsedTimeMonth, requestParameters.elapsedTimeSeconds, requestParameters.elapsedTimeTime, requestParameters.elapsedTimeTimezoneOffset, requestParameters.elapsedTimeYear, requestParameters.endDateTimeDate, requestParameters.endDateTimeDay, requestParameters.endDateTimeHours, requestParameters.endDateTimeMinutes, requestParameters.endDateTimeMonth, requestParameters.endDateTimeNanos, requestParameters.endDateTimeSeconds, requestParameters.endDateTimeTime, requestParameters.endDateTimeTimezoneOffset, requestParameters.endDateTimeYear, requestParameters.endDateTimeStr, requestParameters.id, requestParameters.invoiceId, requestParameters.notes, requestParameters.numberOfDays, requestParameters.paymentDate, requestParameters.projectId, requestParameters.projectManager, requestParameters.projectModelAccount, requestParameters.timesheetId, requestParameters.timezone, requestParameters.usedTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve timecard details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details by User ID.
         * @param {TimecardsApiGetByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserId(requestParameters: TimecardsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserId(requestParameters.email, requestParameters.guid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve timecard basic details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard basic details by User ID.
         * @param {TimecardsApiGetByUserId0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserId_1(requestParameters: TimecardsApiGetByUserId0Request = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimecardsGetByUserId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserId_1(requestParameters.email, requestParameters.guid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve timecard details based on timecard ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details based on timecard ID.
         * @param {TimecardsApiGetDetailsByTimecardIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailsByTimecardId(requestParameters: TimecardsApiGetDetailsByTimecardIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailsByTimecardId(requestParameters.timecardId, requestParameters.flatcustomfields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TVC code for clockin with QR Code using cid.
         * @param {TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTVCForClockinWithQRCodeUsingCid(requestParameters: TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTVCForClockinWithQRCodeUsingCid(requestParameters.cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get timecards by user id.
         * @param {TimecardsApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(requestParameters: TimecardsApiGetUserByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(requestParameters.authorization, requestParameters.type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register device for ClockIn with AssetModel.
         * @param {TimecardsApiRegisterDeviceForClockInWithAssetModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerDeviceForClockInWithAssetModel(requestParameters: TimecardsApiRegisterDeviceForClockInWithAssetModelRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerDeviceForClockInWithAssetModel(requestParameters.accessories, requestParameters.acknowledge, requestParameters.assetID, requestParameters.assetno, requestParameters.assetstatus, requestParameters.assettype, requestParameters.purchaseDate, requestParameters.selfAssign, requestParameters.serialno, requestParameters.service, requestParameters.source, requestParameters.specs, requestParameters.supplier, requestParameters.useStatusCode, requestParameters.userDomain, requestParameters.userMail, requestParameters.userPassword, requestParameters.uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Device verification with DeviceUUID.
         * @param {TimecardsApiVerifyDeviceWithDeviceUUIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyDeviceWithDeviceUUID(requestParameters: TimecardsApiVerifyDeviceWithDeviceUUIDRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyDeviceWithDeviceUUID(requestParameters.deviceUUID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User verification with userid.
         * @param {TimecardsApiVerifyUserWithUseridRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyUserWithUserid(requestParameters: TimecardsApiVerifyUserWithUseridRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyUserWithUserid(requestParameters.adpAssociateOID, requestParameters.allocation, requestParameters.appleUserIdentifier, requestParameters.assignments, requestParameters.authToken, requestParameters.calWeekPref, requestParameters.calendarId, requestParameters.candidateId, requestParameters.careerPathwayId, requestParameters.cellPhone, requestParameters.cid, requestParameters.countryId, requestParameters.createtsDate, requestParameters.createtsDay, requestParameters.createtsHours, requestParameters.createtsMinutes, requestParameters.createtsMonth, requestParameters.createtsNanos, requestParameters.createtsSeconds, requestParameters.createtsTime, requestParameters.createtsTimezoneOffset, requestParameters.createtsYear, requestParameters.createuserid, requestParameters.thumbnail, requestParameters.timecardPeriodPref, requestParameters.timezone, requestParameters.tosVersion, requestParameters.userCountry, requestParameters.userDateFormat, requestParameters.userDateOfBirth, requestParameters.userDisplayName, requestParameters.userEndDate, requestParameters.userName, requestParameters.userNameFormat, requestParameters.userType, requestParameters.view, requestParameters.workerType, requestParameters.workingDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimecardsApi - factory interface
 * @export
 */
export const TimecardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimecardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Clock Out
         * @param {TimecardsApiClockOutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clockOut(requestParameters: TimecardsApiClockOutRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.clockOut(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a past timecard.
         * @param {TimecardsApiCreatePastTimecardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPastTimecard(requestParameters: TimecardsApiCreatePastTimecardRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createPastTimecard(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new timecard.
         * @param {TimecardsApiCreateTimecardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimecard(requestParameters: TimecardsApiCreateTimecardRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createTimecard(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve timecard details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details by User ID.
         * @param {TimecardsApiGetByUserIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId(requestParameters: TimecardsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getByUserId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve timecard basic details based on User ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard basic details by User ID.
         * @param {TimecardsApiGetByUserId0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserId_1(requestParameters: TimecardsApiGetByUserId0Request = {}, options?: AxiosRequestConfig): AxiosPromise<TimecardsGetByUserId200Response> {
            return localVarFp.getByUserId_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve timecard details based on timecard ID with Add Time Cards For Other permission.
         * @summary Retrieve timecard details based on timecard ID.
         * @param {TimecardsApiGetDetailsByTimecardIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailsByTimecardId(requestParameters: TimecardsApiGetDetailsByTimecardIdRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDetailsByTimecardId(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TVC code for clockin with QR Code using cid.
         * @param {TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTVCForClockinWithQRCodeUsingCid(requestParameters: TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getTVCForClockinWithQRCodeUsingCid(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get timecards by user id.
         * @param {TimecardsApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: TimecardsApiGetUserByIdRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getUserById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register device for ClockIn with AssetModel.
         * @param {TimecardsApiRegisterDeviceForClockInWithAssetModelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDeviceForClockInWithAssetModel(requestParameters: TimecardsApiRegisterDeviceForClockInWithAssetModelRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.registerDeviceForClockInWithAssetModel(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Device verification with DeviceUUID.
         * @param {TimecardsApiVerifyDeviceWithDeviceUUIDRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyDeviceWithDeviceUUID(requestParameters: TimecardsApiVerifyDeviceWithDeviceUUIDRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.verifyDeviceWithDeviceUUID(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User verification with userid.
         * @param {TimecardsApiVerifyUserWithUseridRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserWithUserid(requestParameters: TimecardsApiVerifyUserWithUseridRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.verifyUserWithUserid(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clockOut operation in TimecardsApi.
 * @export
 * @interface TimecardsApiClockOutRequest
 */
export type TimecardsApiClockOutRequest = {
    
    /**
    * Authorization
    * @type {string}
    * @memberof TimecardsApiClockOut
    */
    readonly authorization: string
    
}

/**
 * Request parameters for createPastTimecard operation in TimecardsApi.
 * @export
 * @interface TimecardsApiCreatePastTimecardRequest
 */
export type TimecardsApiCreatePastTimecardRequest = {
    
    /**
    * Authorization
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly authorization: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly activity?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly amount?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly approvalRejectionReason?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly billable?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly cardId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly caseNum?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly caseURL?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly categoryCode?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly chargeType?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly cid?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createUserID?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly createtsYear?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly customHours?: string
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly date?: string | Date
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly description?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly elapsedTimeYear?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeYear?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly endDateTimeStr?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly id?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly invoiceId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly notes?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly numberOfDays?: number
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly paymentDate?: string | Date
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly projectId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly projectManager?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly projectModelAccount?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly ptoComputed?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly source?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeYear?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly startDateTimeStr?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly status?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly sumOfElapsedTime?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly timesheetId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly timezone?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreatePastTimecard
    */
    readonly usedTime?: number
    
}

/**
 * Request parameters for createTimecard operation in TimecardsApi.
 * @export
 * @interface TimecardsApiCreateTimecardRequest
 */
export type TimecardsApiCreateTimecardRequest = {
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly createtsYear?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly customHours?: string
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly date?: string | Date
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly description?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly elapsedTimeYear?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeYear?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly endDateTimeStr?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly id?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly invoiceId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly notes?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly numberOfDays?: number
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly paymentDate?: string | Date
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly projectId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly projectManager?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly projectModelAccount?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly timesheetId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly timezone?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiCreateTimecard
    */
    readonly usedTime?: number
    
}

/**
 * Request parameters for getByUserId operation in TimecardsApi.
 * @export
 * @interface TimecardsApiGetByUserIdRequest
 */
export type TimecardsApiGetByUserIdRequest = {
    
    /**
    * email of the user.
    * @type {string}
    * @memberof TimecardsApiGetByUserId
    */
    readonly email?: string
    
    /**
    * Graphical user ID.
    * @type {string}
    * @memberof TimecardsApiGetByUserId
    */
    readonly guid?: string
    
}

/**
 * Request parameters for getByUserId_1 operation in TimecardsApi.
 * @export
 * @interface TimecardsApiGetByUserId0Request
 */
export type TimecardsApiGetByUserId0Request = {
    
    /**
    * email of the user.
    * @type {string}
    * @memberof TimecardsApiGetByUserId0
    */
    readonly email?: string
    
    /**
    * Graphical user ID.
    * @type {string}
    * @memberof TimecardsApiGetByUserId0
    */
    readonly guid?: string
    
}

/**
 * Request parameters for getDetailsByTimecardId operation in TimecardsApi.
 * @export
 * @interface TimecardsApiGetDetailsByTimecardIdRequest
 */
export type TimecardsApiGetDetailsByTimecardIdRequest = {
    
    /**
    * Timecard ID of the timecard.
    * @type {number}
    * @memberof TimecardsApiGetDetailsByTimecardId
    */
    readonly timecardId: number
    
    /**
    * 
    * @type {boolean}
    * @memberof TimecardsApiGetDetailsByTimecardId
    */
    readonly flatcustomfields?: boolean
    
}

/**
 * Request parameters for getTVCForClockinWithQRCodeUsingCid operation in TimecardsApi.
 * @export
 * @interface TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest
 */
export type TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest = {
    
    /**
    * cid
    * @type {number}
    * @memberof TimecardsApiGetTVCForClockinWithQRCodeUsingCid
    */
    readonly cid: number
    
}

/**
 * Request parameters for getUserById operation in TimecardsApi.
 * @export
 * @interface TimecardsApiGetUserByIdRequest
 */
export type TimecardsApiGetUserByIdRequest = {
    
    /**
    * Authorization
    * @type {string}
    * @memberof TimecardsApiGetUserById
    */
    readonly authorization: string
    
    /**
    * type
    * @type {string}
    * @memberof TimecardsApiGetUserById
    */
    readonly type?: string
    
}

/**
 * Request parameters for registerDeviceForClockInWithAssetModel operation in TimecardsApi.
 * @export
 * @interface TimecardsApiRegisterDeviceForClockInWithAssetModelRequest
 */
export type TimecardsApiRegisterDeviceForClockInWithAssetModelRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly accessories?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly acknowledge?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly assetID?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly assetno?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly assetstatus?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly assettype?: string
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly purchaseDate?: string | Date
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly selfAssign?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly serialno?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly service?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly source?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly specs?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly supplier?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly useStatusCode?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly userDomain?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly userMail?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly userPassword?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiRegisterDeviceForClockInWithAssetModel
    */
    readonly uuid?: string
    
}

/**
 * Request parameters for verifyDeviceWithDeviceUUID operation in TimecardsApi.
 * @export
 * @interface TimecardsApiVerifyDeviceWithDeviceUUIDRequest
 */
export type TimecardsApiVerifyDeviceWithDeviceUUIDRequest = {
    
    /**
    * deviceUUID
    * @type {string}
    * @memberof TimecardsApiVerifyDeviceWithDeviceUUID
    */
    readonly deviceUUID: string
    
}

/**
 * Request parameters for verifyUserWithUserid operation in TimecardsApi.
 * @export
 * @interface TimecardsApiVerifyUserWithUseridRequest
 */
export type TimecardsApiVerifyUserWithUseridRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly adpAssociateOID?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly allocation?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly appleUserIdentifier?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly assignments?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly authToken?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly calWeekPref?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly calendarId?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly candidateId?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly careerPathwayId?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly cellPhone?: string
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly cid?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly countryId?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsDate?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsDay?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsHours?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsMinutes?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsMonth?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsNanos?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsSeconds?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsTime?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsTimezoneOffset?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createtsYear?: number
    
    /**
    * 
    * @type {number}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly createuserid?: number
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly thumbnail?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly timecardPeriodPref?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly timezone?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly tosVersion?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userCountry?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userDateFormat?: string
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userDateOfBirth?: string | Date
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userDisplayName?: string
    
    /**
    * 
    * @type {string | Date}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userEndDate?: string | Date
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userName?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userNameFormat?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly userType?: string
    
    /**
    * 
    * @type {boolean}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly view?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly workerType?: string
    
    /**
    * 
    * @type {string}
    * @memberof TimecardsApiVerifyUserWithUserid
    */
    readonly workingDays?: string
    
}

/**
 * TimecardsApiGenerated - object-oriented interface
 * @export
 * @class TimecardsApiGenerated
 * @extends {BaseAPI}
 */
export class TimecardsApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Clock Out
     * @param {TimecardsApiClockOutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public clockOut(requestParameters: TimecardsApiClockOutRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).clockOut(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a past timecard.
     * @param {TimecardsApiCreatePastTimecardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public createPastTimecard(requestParameters: TimecardsApiCreatePastTimecardRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).createPastTimecard(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new timecard.
     * @param {TimecardsApiCreateTimecardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public createTimecard(requestParameters: TimecardsApiCreateTimecardRequest = {}, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).createTimecard(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve timecard details based on User ID with Add Time Cards For Other permission.
     * @summary Retrieve timecard details by User ID.
     * @param {TimecardsApiGetByUserIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public getByUserId(requestParameters: TimecardsApiGetByUserIdRequest = {}, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).getByUserId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve timecard basic details based on User ID with Add Time Cards For Other permission.
     * @summary Retrieve timecard basic details by User ID.
     * @param {TimecardsApiGetByUserId0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public getByUserId_1(requestParameters: TimecardsApiGetByUserId0Request = {}, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).getByUserId_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve timecard details based on timecard ID with Add Time Cards For Other permission.
     * @summary Retrieve timecard details based on timecard ID.
     * @param {TimecardsApiGetDetailsByTimecardIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public getDetailsByTimecardId(requestParameters: TimecardsApiGetDetailsByTimecardIdRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).getDetailsByTimecardId(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TVC code for clockin with QR Code using cid.
     * @param {TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public getTVCForClockinWithQRCodeUsingCid(requestParameters: TimecardsApiGetTVCForClockinWithQRCodeUsingCidRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).getTVCForClockinWithQRCodeUsingCid(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get timecards by user id.
     * @param {TimecardsApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public getUserById(requestParameters: TimecardsApiGetUserByIdRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).getUserById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register device for ClockIn with AssetModel.
     * @param {TimecardsApiRegisterDeviceForClockInWithAssetModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public registerDeviceForClockInWithAssetModel(requestParameters: TimecardsApiRegisterDeviceForClockInWithAssetModelRequest = {}, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).registerDeviceForClockInWithAssetModel(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Device verification with DeviceUUID.
     * @param {TimecardsApiVerifyDeviceWithDeviceUUIDRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public verifyDeviceWithDeviceUUID(requestParameters: TimecardsApiVerifyDeviceWithDeviceUUIDRequest, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).verifyDeviceWithDeviceUUID(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User verification with userid.
     * @param {TimecardsApiVerifyUserWithUseridRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimecardsApiGenerated
     */
    public verifyUserWithUserid(requestParameters: TimecardsApiVerifyUserWithUseridRequest = {}, options?: AxiosRequestConfig) {
        return TimecardsApiFp(this.configuration).verifyUserWithUserid(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
